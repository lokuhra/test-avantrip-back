
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
  "errors"
  "os"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
    return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
  Endpoint  string
  Secret    string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
  endpoint := DefaultEndpoint
  secret   := Secret
	if options != nil {
    endpoint = options.Endpoint
    secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}


var DefaultEndpoint = "https://us1.prisma.sh/leandro-bernardi-40b895/test-avantrip/dev"
var Secret          = ""


      func (client *Client) Flights (params FlightsWhereUniqueInput) *FlightsExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"FlightsWhereUniqueInput!", "Flights"},
          "flights",
          []string{"id","scales","price","description","link","img"})

        return &FlightsExec{ret}
      }

      type FlightsesParams struct {
        Where *FlightsWhereInput `json:"where,omitempty"`
OrderBy *FlightsOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Flightses (params *FlightsesParams) *FlightsExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"FlightsWhereInput", "FlightsOrderByInput", "Flights"},
          "flightses",
          []string{"id","scales","price","description","link","img"})

        return &FlightsExecArray{ret}
      }

      type FlightsesConnectionParams struct {
        Where *FlightsWhereInput `json:"where,omitempty"`
OrderBy *FlightsOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) FlightsesConnection (params *FlightsesConnectionParams) (FlightsConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) Stays (params StaysWhereUniqueInput) *StaysExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"StaysWhereUniqueInput!", "Stays"},
          "stays",
          []string{"id","name","bestPrice"})

        return &StaysExec{ret}
      }

      type StaysesParams struct {
        Where *StaysWhereInput `json:"where,omitempty"`
OrderBy *StaysOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Stayses (params *StaysesParams) *StaysExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"StaysWhereInput", "StaysOrderByInput", "Stays"},
          "stayses",
          []string{"id","name","bestPrice"})

        return &StaysExecArray{ret}
      }

      type StaysesConnectionParams struct {
        Where *StaysWhereInput `json:"where,omitempty"`
OrderBy *StaysOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) StaysesConnection (params *StaysesConnectionParams) (StaysConnectionExec) {
        panic("not implemented")
      }



      func (client *Client) CreateFlights (params FlightsCreateInput) *FlightsExec {
        ret := client.Client.Create(
          params,
          [2]string{"FlightsCreateInput!", "Flights"},
          "createFlights",
          []string{"id","scales","price","description","link","img"})

        return &FlightsExec{ret}
      }

      type FlightsUpdateParams struct {
        Data FlightsUpdateInput `json:"data"`
Where FlightsWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateFlights (params FlightsUpdateParams) *FlightsExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"FlightsUpdateInput!", "FlightsWhereUniqueInput!", "Flights"},
                 "updateFlights",
                 []string{"id","scales","price","description","link","img"})

        return &FlightsExec{ret}
      }

      type FlightsUpdateManyParams struct {
        Data FlightsUpdateInput `json:"data"`
Where *FlightsWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyFlightses (params FlightsUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"FlightsUpdateInput!", "FlightsWhereInput"},
          "updateManyFlightses")
        return &BatchPayloadExec{exec}
      }

      type FlightsUpsertParams struct {
        Where FlightsWhereUniqueInput `json:"where"`
Create FlightsCreateInput `json:"create"`
Update FlightsUpdateInput `json:"update"`
      }
      func (client *Client) UpsertFlights (params FlightsUpsertParams) *FlightsExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"FlightsWhereUniqueInput!", "FlightsCreateInput!", "FlightsUpdateInput!","Flights"},
          "upsertFlights",
          []string{"id","scales","price","description","link","img"})

        return &FlightsExec{ret}
      }

      func (client *Client) DeleteFlights (params FlightsWhereUniqueInput) *FlightsExec {
        ret := client.Client.Delete(
          params,
          [2]string{"FlightsWhereUniqueInput!", "Flights"},
          "deleteFlights",
          []string{"id","scales","price","description","link","img"})

        return &FlightsExec{ret}
      }

      func (client *Client) DeleteManyFlightses (params *FlightsWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "FlightsWhereInput", "deleteManyFlightses")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateStays (params StaysCreateInput) *StaysExec {
        ret := client.Client.Create(
          params,
          [2]string{"StaysCreateInput!", "Stays"},
          "createStays",
          []string{"id","name","bestPrice"})

        return &StaysExec{ret}
      }

      type StaysUpdateParams struct {
        Data StaysUpdateInput `json:"data"`
Where StaysWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateStays (params StaysUpdateParams) *StaysExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"StaysUpdateInput!", "StaysWhereUniqueInput!", "Stays"},
                 "updateStays",
                 []string{"id","name","bestPrice"})

        return &StaysExec{ret}
      }

      type StaysUpdateManyParams struct {
        Data StaysUpdateInput `json:"data"`
Where *StaysWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyStayses (params StaysUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"StaysUpdateInput!", "StaysWhereInput"},
          "updateManyStayses")
        return &BatchPayloadExec{exec}
      }

      type StaysUpsertParams struct {
        Where StaysWhereUniqueInput `json:"where"`
Create StaysCreateInput `json:"create"`
Update StaysUpdateInput `json:"update"`
      }
      func (client *Client) UpsertStays (params StaysUpsertParams) *StaysExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"StaysWhereUniqueInput!", "StaysCreateInput!", "StaysUpdateInput!","Stays"},
          "upsertStays",
          []string{"id","name","bestPrice"})

        return &StaysExec{ret}
      }

      func (client *Client) DeleteStays (params StaysWhereUniqueInput) *StaysExec {
        ret := client.Client.Delete(
          params,
          [2]string{"StaysWhereUniqueInput!", "Stays"},
          "deleteStays",
          []string{"id","name","bestPrice"})

        return &StaysExec{ret}
      }

      func (client *Client) DeleteManyStayses (params *StaysWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "StaysWhereInput", "deleteManyStayses")
        return &BatchPayloadExec{exec}
      }


        type FlightsOrderByInput string
        const (
          FlightsOrderByInputIDAsc FlightsOrderByInput = "id_ASC"
FlightsOrderByInputIDDesc FlightsOrderByInput = "id_DESC"
FlightsOrderByInputScalesAsc FlightsOrderByInput = "scales_ASC"
FlightsOrderByInputScalesDesc FlightsOrderByInput = "scales_DESC"
FlightsOrderByInputPriceAsc FlightsOrderByInput = "price_ASC"
FlightsOrderByInputPriceDesc FlightsOrderByInput = "price_DESC"
FlightsOrderByInputDescriptionAsc FlightsOrderByInput = "description_ASC"
FlightsOrderByInputDescriptionDesc FlightsOrderByInput = "description_DESC"
FlightsOrderByInputLinkAsc FlightsOrderByInput = "link_ASC"
FlightsOrderByInputLinkDesc FlightsOrderByInput = "link_DESC"
FlightsOrderByInputImgAsc FlightsOrderByInput = "img_ASC"
FlightsOrderByInputImgDesc FlightsOrderByInput = "img_DESC"
FlightsOrderByInputCreatedAtAsc FlightsOrderByInput = "createdAt_ASC"
FlightsOrderByInputCreatedAtDesc FlightsOrderByInput = "createdAt_DESC"
FlightsOrderByInputUpdatedAtAsc FlightsOrderByInput = "updatedAt_ASC"
FlightsOrderByInputUpdatedAtDesc FlightsOrderByInput = "updatedAt_DESC"
          )

        type StaysOrderByInput string
        const (
          StaysOrderByInputIDAsc StaysOrderByInput = "id_ASC"
StaysOrderByInputIDDesc StaysOrderByInput = "id_DESC"
StaysOrderByInputNameAsc StaysOrderByInput = "name_ASC"
StaysOrderByInputNameDesc StaysOrderByInput = "name_DESC"
StaysOrderByInputBestPriceAsc StaysOrderByInput = "bestPrice_ASC"
StaysOrderByInputBestPriceDesc StaysOrderByInput = "bestPrice_DESC"
StaysOrderByInputCreatedAtAsc StaysOrderByInput = "createdAt_ASC"
StaysOrderByInputCreatedAtDesc StaysOrderByInput = "createdAt_DESC"
StaysOrderByInputUpdatedAtAsc StaysOrderByInput = "updatedAt_ASC"
StaysOrderByInputUpdatedAtDesc StaysOrderByInput = "updatedAt_DESC"
          )

        type MutationType string
        const (
          MutationTypeCreated MutationType = "CREATED"
MutationTypeUpdated MutationType = "UPDATED"
MutationTypeDeleted MutationType = "DELETED"
          )

      type StaysUpdateDataInput struct {
        Name *string `json:"name,omitempty"`
BestPrice *int32 `json:"bestPrice,omitempty"`
          }

      type FlightsWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type FlightsUpdateInput struct {
        ParentId *StaysUpdateOneRequiredInput `json:"parentId,omitempty"`
Scales *string `json:"scales,omitempty"`
Price *int32 `json:"price,omitempty"`
Description *string `json:"description,omitempty"`
Link *string `json:"link,omitempty"`
Img *string `json:"img,omitempty"`
          }

      type FlightsWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
ParentId *StaysWhereInput `json:"parentId,omitempty"`
Scales *string `json:"scales,omitempty"`
ScalesNot *string `json:"scales_not,omitempty"`
ScalesIn []string `json:"scales_in,omitempty"`
ScalesNotIn []string `json:"scales_not_in,omitempty"`
ScalesLt *string `json:"scales_lt,omitempty"`
ScalesLte *string `json:"scales_lte,omitempty"`
ScalesGt *string `json:"scales_gt,omitempty"`
ScalesGte *string `json:"scales_gte,omitempty"`
ScalesContains *string `json:"scales_contains,omitempty"`
ScalesNotContains *string `json:"scales_not_contains,omitempty"`
ScalesStartsWith *string `json:"scales_starts_with,omitempty"`
ScalesNotStartsWith *string `json:"scales_not_starts_with,omitempty"`
ScalesEndsWith *string `json:"scales_ends_with,omitempty"`
ScalesNotEndsWith *string `json:"scales_not_ends_with,omitempty"`
Price *int32 `json:"price,omitempty"`
PriceNot *int32 `json:"price_not,omitempty"`
PriceIn []int32 `json:"price_in,omitempty"`
PriceNotIn []int32 `json:"price_not_in,omitempty"`
PriceLt *int32 `json:"price_lt,omitempty"`
PriceLte *int32 `json:"price_lte,omitempty"`
PriceGt *int32 `json:"price_gt,omitempty"`
PriceGte *int32 `json:"price_gte,omitempty"`
Description *string `json:"description,omitempty"`
DescriptionNot *string `json:"description_not,omitempty"`
DescriptionIn []string `json:"description_in,omitempty"`
DescriptionNotIn []string `json:"description_not_in,omitempty"`
DescriptionLt *string `json:"description_lt,omitempty"`
DescriptionLte *string `json:"description_lte,omitempty"`
DescriptionGt *string `json:"description_gt,omitempty"`
DescriptionGte *string `json:"description_gte,omitempty"`
DescriptionContains *string `json:"description_contains,omitempty"`
DescriptionNotContains *string `json:"description_not_contains,omitempty"`
DescriptionStartsWith *string `json:"description_starts_with,omitempty"`
DescriptionNotStartsWith *string `json:"description_not_starts_with,omitempty"`
DescriptionEndsWith *string `json:"description_ends_with,omitempty"`
DescriptionNotEndsWith *string `json:"description_not_ends_with,omitempty"`
Link *string `json:"link,omitempty"`
LinkNot *string `json:"link_not,omitempty"`
LinkIn []string `json:"link_in,omitempty"`
LinkNotIn []string `json:"link_not_in,omitempty"`
LinkLt *string `json:"link_lt,omitempty"`
LinkLte *string `json:"link_lte,omitempty"`
LinkGt *string `json:"link_gt,omitempty"`
LinkGte *string `json:"link_gte,omitempty"`
LinkContains *string `json:"link_contains,omitempty"`
LinkNotContains *string `json:"link_not_contains,omitempty"`
LinkStartsWith *string `json:"link_starts_with,omitempty"`
LinkNotStartsWith *string `json:"link_not_starts_with,omitempty"`
LinkEndsWith *string `json:"link_ends_with,omitempty"`
LinkNotEndsWith *string `json:"link_not_ends_with,omitempty"`
Img *string `json:"img,omitempty"`
ImgNot *string `json:"img_not,omitempty"`
ImgIn []string `json:"img_in,omitempty"`
ImgNotIn []string `json:"img_not_in,omitempty"`
ImgLt *string `json:"img_lt,omitempty"`
ImgLte *string `json:"img_lte,omitempty"`
ImgGt *string `json:"img_gt,omitempty"`
ImgGte *string `json:"img_gte,omitempty"`
ImgContains *string `json:"img_contains,omitempty"`
ImgNotContains *string `json:"img_not_contains,omitempty"`
ImgStartsWith *string `json:"img_starts_with,omitempty"`
ImgNotStartsWith *string `json:"img_not_starts_with,omitempty"`
ImgEndsWith *string `json:"img_ends_with,omitempty"`
ImgNotEndsWith *string `json:"img_not_ends_with,omitempty"`
And []FlightsWhereInput `json:"AND,omitempty"`
Or []FlightsWhereInput `json:"OR,omitempty"`
Not []FlightsWhereInput `json:"NOT,omitempty"`
          }

      type StaysCreateInput struct {
        Name *string `json:"name,omitempty"`
BestPrice *int32 `json:"bestPrice,omitempty"`
          }

      type StaysUpdateInput struct {
        Name *string `json:"name,omitempty"`
BestPrice *int32 `json:"bestPrice,omitempty"`
          }

      type FlightsCreateInput struct {
        ParentId StaysCreateOneInput `json:"parentId"`
Scales *string `json:"scales,omitempty"`
Price *int32 `json:"price,omitempty"`
Description *string `json:"description,omitempty"`
Link *string `json:"link,omitempty"`
Img *string `json:"img,omitempty"`
          }

      type StaysCreateOneInput struct {
        Create *StaysCreateInput `json:"create,omitempty"`
Connect *StaysWhereUniqueInput `json:"connect,omitempty"`
          }

      type FlightsSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *FlightsWhereInput `json:"node,omitempty"`
And []FlightsSubscriptionWhereInput `json:"AND,omitempty"`
Or []FlightsSubscriptionWhereInput `json:"OR,omitempty"`
Not []FlightsSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type StaysWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type StaysUpsertNestedInput struct {
        Update StaysUpdateDataInput `json:"update"`
Create StaysCreateInput `json:"create"`
          }

      type StaysWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Name *string `json:"name,omitempty"`
NameNot *string `json:"name_not,omitempty"`
NameIn []string `json:"name_in,omitempty"`
NameNotIn []string `json:"name_not_in,omitempty"`
NameLt *string `json:"name_lt,omitempty"`
NameLte *string `json:"name_lte,omitempty"`
NameGt *string `json:"name_gt,omitempty"`
NameGte *string `json:"name_gte,omitempty"`
NameContains *string `json:"name_contains,omitempty"`
NameNotContains *string `json:"name_not_contains,omitempty"`
NameStartsWith *string `json:"name_starts_with,omitempty"`
NameNotStartsWith *string `json:"name_not_starts_with,omitempty"`
NameEndsWith *string `json:"name_ends_with,omitempty"`
NameNotEndsWith *string `json:"name_not_ends_with,omitempty"`
BestPrice *int32 `json:"bestPrice,omitempty"`
BestPriceNot *int32 `json:"bestPrice_not,omitempty"`
BestPriceIn []int32 `json:"bestPrice_in,omitempty"`
BestPriceNotIn []int32 `json:"bestPrice_not_in,omitempty"`
BestPriceLt *int32 `json:"bestPrice_lt,omitempty"`
BestPriceLte *int32 `json:"bestPrice_lte,omitempty"`
BestPriceGt *int32 `json:"bestPrice_gt,omitempty"`
BestPriceGte *int32 `json:"bestPrice_gte,omitempty"`
And []StaysWhereInput `json:"AND,omitempty"`
Or []StaysWhereInput `json:"OR,omitempty"`
Not []StaysWhereInput `json:"NOT,omitempty"`
          }

      type StaysUpdateOneRequiredInput struct {
        Create *StaysCreateInput `json:"create,omitempty"`
Update *StaysUpdateDataInput `json:"update,omitempty"`
Upsert *StaysUpsertNestedInput `json:"upsert,omitempty"`
Connect *StaysWhereUniqueInput `json:"connect,omitempty"`
          }

      type StaysSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *StaysWhereInput `json:"node,omitempty"`
And []StaysSubscriptionWhereInput `json:"AND,omitempty"`
Or []StaysSubscriptionWhereInput `json:"OR,omitempty"`
Not []StaysSubscriptionWhereInput `json:"NOT,omitempty"`
          }



        type FlightsConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *FlightsConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *FlightsConnectionExec) Edges() *FlightsEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "FlightsEdge"},
                    "edges",
                    []string{"cursor"})

                  return &FlightsEdgeExec{ret}
                }

                  func (instance *FlightsConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateFlights"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance FlightsConnectionExec) Exec(ctx context.Context) (*FlightsConnection, error) {
            var v FlightsConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance FlightsConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type FlightsConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance FlightsConnectionExecArray) Exec(ctx context.Context) ([]FlightsConnection, error) {
            var v []FlightsConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type FlightsConnection struct {
          
        }

        type FlightsSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *FlightsSubscriptionPayloadExec) Node() *FlightsExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Flights"},
                    "node",
                    []string{"id","scales","price","description","link","img"})

                  return &FlightsExec{ret}
                }

                func (instance *FlightsSubscriptionPayloadExec) PreviousValues() *FlightsPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "FlightsPreviousValues"},
                    "previousValues",
                    []string{"id","scales","price","description","link","img"})

                  return &FlightsPreviousValuesExec{ret}
                }

          func (instance FlightsSubscriptionPayloadExec) Exec(ctx context.Context) (*FlightsSubscriptionPayload, error) {
            var v FlightsSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance FlightsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type FlightsSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance FlightsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FlightsSubscriptionPayload, error) {
            var v []FlightsSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type FlightsSubscriptionPayload struct {
          UpdatedFields []string `json:"updatedFields,omitempty"`
        }


        type StaysPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance StaysPreviousValuesExec) Exec(ctx context.Context) (*StaysPreviousValues, error) {
            var v StaysPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance StaysPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type StaysPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance StaysPreviousValuesExecArray) Exec(ctx context.Context) ([]StaysPreviousValues, error) {
            var v []StaysPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type StaysPreviousValues struct {
          ID string `json:"id"`
Name *string `json:"name,omitempty"`
BestPrice *int32 `json:"bestPrice,omitempty"`
        }


        type StaysExec struct {
          exec *prisma.Exec
        }

        

          func (instance StaysExec) Exec(ctx context.Context) (*Stays, error) {
            var v Stays
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance StaysExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type StaysExecArray struct {
            exec *prisma.Exec
          }

          func (instance StaysExecArray) Exec(ctx context.Context) ([]Stays, error) {
            var v []Stays
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type Stays struct {
          ID string `json:"id"`
Name *string `json:"name,omitempty"`
BestPrice *int32 `json:"bestPrice,omitempty"`
        }

        type FlightsPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance FlightsPreviousValuesExec) Exec(ctx context.Context) (*FlightsPreviousValues, error) {
            var v FlightsPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance FlightsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type FlightsPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance FlightsPreviousValuesExecArray) Exec(ctx context.Context) ([]FlightsPreviousValues, error) {
            var v []FlightsPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type FlightsPreviousValues struct {
          ID string `json:"id"`
Scales *string `json:"scales,omitempty"`
Price *int32 `json:"price,omitempty"`
Description *string `json:"description,omitempty"`
Link *string `json:"link,omitempty"`
Img *string `json:"img,omitempty"`
        }

        type FlightsExec struct {
          exec *prisma.Exec
        }

        
                func (instance *FlightsExec) ParentId() *StaysExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Stays"},
                    "parentId",
                    []string{"id","name","bestPrice"})

                  return &StaysExec{ret}
                }

          func (instance FlightsExec) Exec(ctx context.Context) (*Flights, error) {
            var v Flights
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance FlightsExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type FlightsExecArray struct {
            exec *prisma.Exec
          }

          func (instance FlightsExecArray) Exec(ctx context.Context) ([]Flights, error) {
            var v []Flights
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type Flights struct {
          ID string `json:"id"`
Scales *string `json:"scales,omitempty"`
Price *int32 `json:"price,omitempty"`
Description *string `json:"description,omitempty"`
Link *string `json:"link,omitempty"`
Img *string `json:"img,omitempty"`
        }

        type StaysEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *StaysEdgeExec) Node() *StaysExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Stays"},
                    "node",
                    []string{"id","name","bestPrice"})

                  return &StaysExec{ret}
                }

          func (instance StaysEdgeExec) Exec(ctx context.Context) (*StaysEdge, error) {
            var v StaysEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance StaysEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type StaysEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance StaysEdgeExecArray) Exec(ctx context.Context) ([]StaysEdge, error) {
            var v []StaysEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type StaysEdge struct {
          Cursor string `json:"cursor"`
        }

        type FlightsEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *FlightsEdgeExec) Node() *FlightsExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Flights"},
                    "node",
                    []string{"id","scales","price","description","link","img"})

                  return &FlightsExec{ret}
                }

          func (instance FlightsEdgeExec) Exec(ctx context.Context) (*FlightsEdge, error) {
            var v FlightsEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance FlightsEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type FlightsEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance FlightsEdgeExecArray) Exec(ctx context.Context) ([]FlightsEdge, error) {
            var v []FlightsEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type FlightsEdge struct {
          Cursor string `json:"cursor"`
        }

        type StaysConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *StaysConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *StaysConnectionExec) Edges() *StaysEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "StaysEdge"},
                    "edges",
                    []string{"cursor"})

                  return &StaysEdgeExec{ret}
                }

                  func (instance *StaysConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateStays"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance StaysConnectionExec) Exec(ctx context.Context) (*StaysConnection, error) {
            var v StaysConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance StaysConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type StaysConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance StaysConnectionExecArray) Exec(ctx context.Context) ([]StaysConnection, error) {
            var v []StaysConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type StaysConnection struct {
          
        }

        type PageInfoExec struct {
          exec *prisma.Exec
        }

        

          func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
            var v PageInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PageInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
            var v []PageInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PageInfo struct {
          HasNextPage bool `json:"hasNextPage"`
HasPreviousPage bool `json:"hasPreviousPage"`
StartCursor *string `json:"startCursor,omitempty"`
EndCursor *string `json:"endCursor,omitempty"`
        }

        type StaysSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *StaysSubscriptionPayloadExec) Node() *StaysExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Stays"},
                    "node",
                    []string{"id","name","bestPrice"})

                  return &StaysExec{ret}
                }

                func (instance *StaysSubscriptionPayloadExec) PreviousValues() *StaysPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "StaysPreviousValues"},
                    "previousValues",
                    []string{"id","name","bestPrice"})

                  return &StaysPreviousValuesExec{ret}
                }

          func (instance StaysSubscriptionPayloadExec) Exec(ctx context.Context) (*StaysSubscriptionPayload, error) {
            var v StaysSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance StaysSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type StaysSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance StaysSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]StaysSubscriptionPayload, error) {
            var v []StaysSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type StaysSubscriptionPayload struct {
          UpdatedFields []string `json:"updatedFields,omitempty"`
        }





        